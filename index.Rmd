---
title: "Computational Musicology"
author: "DaniÃ«l Vermaas"
date: "`r Sys.Date()`"
output: 
  flexdashboard::flex_dashboard:
    storyboard: true
    css: styles.css
    source_code: https://github.com/dvermaas/ComputationalMusicology
    self_contained: false
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
# Modules to import
library(ggpubr)
library(cowplot)
library(ggplot2)
library(dplyr)
library(tidyverse)
library(spotifyr)
library(plotly)
library(knitr)
library(DT)
library(showtext)
library(compmus)
library(gridExtra)
font.add("TTNorms", "TTNorms-ExtraBold.otf")
showtext.auto()
```

```{r, include=FALSE}
corpus <- get_playlist_audio_features("", "58spcwLelMvMpKvObWuwbN") %>%
  mutate(mode = ifelse(mode == 0, "Minor", "Major")) %>% 
  mutate(artists.name = map_chr(track.album.artists, function(x) x$name[1]))
```

```{r, include=FALSE}
# Define your own theme function below
theme_vapor <- function() {
    theme_minimal() +
    theme(
      text = element_text(family = "TTNorms", color = "#eb34b1", size=14),
      plot.title = element_text(hjust = 0.5),
      plot.background = element_rect(fill = "#181818"),
      panel.background  = element_rect(fill = "#121212"),
      legend.key = element_rect(fill = "#181818"),
      #legend.background = element_rect(fill = "#131313"),
      panel.grid = element_line(color = "#eb34b1")
    )
}
```

### Chordogram {data-commentary-width=400}

``` {r, echo = FALSE}
circshift <- function(v, n) {
  if (n == 0) v else c(tail(v, n), head(v, -n))
}
#      C     C#    D     Eb    E     F     F#    G     Ab    A     Bb    B
major_chord <-
  c(   1,    0,    0,    0,    1,    0,    0,    1,    0,    0,    0,    0)
minor_chord <-
  c(   1,    0,    0,    1,    0,    0,    0,    1,    0,    0,    0,    0)
seventh_chord <-
  c(   1,    0,    0,    0,    1,    0,    0,    1,    0,    0,    1,    0)
major_key <-
  c(6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88)
minor_key <-
  c(6.33, 2.68, 3.52, 5.38, 2.60, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17)
chord_templates <-
  tribble(
    ~name, ~template,
    "Gb:7", circshift(seventh_chord, 6),
    "Gb:maj", circshift(major_chord, 6),
    "Bb:min", circshift(minor_chord, 10),
    "Db:maj", circshift(major_chord, 1),
    "F:min", circshift(minor_chord, 5),
    "Ab:7", circshift(seventh_chord, 8),
    "Ab:maj", circshift(major_chord, 8),
    "C:min", circshift(minor_chord, 0),
    "Eb:7", circshift(seventh_chord, 3),
    "Eb:maj", circshift(major_chord, 3),
    "G:min", circshift(minor_chord, 7),
    "Bb:7", circshift(seventh_chord, 10),
    "Bb:maj", circshift(major_chord, 10),
    "D:min", circshift(minor_chord, 2),
    "F:7", circshift(seventh_chord, 5),
    "F:maj", circshift(major_chord, 5),
    "A:min", circshift(minor_chord, 9),
    "C:7", circshift(seventh_chord, 0),
    "C:maj", circshift(major_chord, 0),
    "E:min", circshift(minor_chord, 4),
    "G:7", circshift(seventh_chord, 7),
    "G:maj", circshift(major_chord, 7),
    "B:min", circshift(minor_chord, 11),
    "D:7", circshift(seventh_chord, 2),
    "D:maj", circshift(major_chord, 2),
    "F#:min", circshift(minor_chord, 6),
    "A:7", circshift(seventh_chord, 9),
    "A:maj", circshift(major_chord, 9),
    "C#:min", circshift(minor_chord, 1),
    "E:7", circshift(seventh_chord, 4),
    "E:maj", circshift(major_chord, 4),
    "G#:min", circshift(minor_chord, 8),
    "B:7", circshift(seventh_chord, 11),
    "B:maj", circshift(major_chord, 11),
    "D#:min", circshift(minor_chord, 3)
  )
key_templates <-
  tribble(
    ~name, ~template,
    "Gb:maj", circshift(major_key, 6),
    "Bb:min", circshift(minor_key, 10),
    "Db:maj", circshift(major_key, 1),
    "F:min", circshift(minor_key, 5),
    "Ab:maj", circshift(major_key, 8),
    "C:min", circshift(minor_key, 0),
    "Eb:maj", circshift(major_key, 3),
    "G:min", circshift(minor_key, 7),
    "Bb:maj", circshift(major_key, 10),
    "D:min", circshift(minor_key, 2),
    "F:maj", circshift(major_key, 5),
    "A:min", circshift(minor_key, 9),
    "C:maj", circshift(major_key, 0),
    "E:min", circshift(minor_key, 4),
    "G:maj", circshift(major_key, 7),
    "B:min", circshift(minor_key, 11),
    "D:maj", circshift(major_key, 2),
    "F#:min", circshift(minor_key, 6),
    "A:maj", circshift(major_key, 9),
    "C#:min", circshift(minor_key, 1),
    "E:maj", circshift(major_key, 4),
    "G#:min", circshift(minor_key, 8),
    "B:maj", circshift(major_key, 11),
    "D#:min", circshift(minor_key, 3)
  )
daysofthunder <-
  get_tidy_audio_analysis("6tJPdGKrbAeyhkkhn44RHR") %>%
  compmus_align(sections, segments) %>%
  select(sections) %>%
  unnest(sections) %>%
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "mean", norm = "manhattan"
      )
  )
daysofthunder_plot <- daysofthunder %>% 
  compmus_match_pitch_template(
    key_templates,         # Change to chord_templates if descired
    method = "euclidean",  # Try different distance metrics
    norm = "manhattan"     # Try different norms
  ) %>%
  ggplot(
    aes(x = start + duration / 2, width = duration, y = name, fill = d)
  ) +
  geom_tile() +
  scale_fill_viridis_c(guide = "none") +
  theme_minimal() +
  labs(x = "Time (s)", y = "", , title="Days of thunder - The Midnight")  + theme_vapor()

wildones <-
  get_tidy_audio_analysis("03FPFGGmCFCFX9X7vNB3JW") %>%
  compmus_align(sections, segments) %>%
  select(sections) %>%
  unnest(sections) %>%
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "mean", norm = "manhattan"
      )
  )
wildones_plot <- wildones %>% 
  compmus_match_pitch_template(
    key_templates,         # Change to chord_templates if descired
    method = "euclidean",  # Try different distance metrics
    norm = "manhattan"     # Try different norms
  ) %>%
  ggplot(
    aes(x = start + duration / 2, width = duration, y = name, fill = d)
  ) +
  geom_tile() +
  scale_fill_viridis_c(guide = "none") +
  theme_minimal() +
  labs(x = "Time (s)", y = "", title="Wild Ones - FM-84") + theme_vapor()
plot_grid(daysofthunder_plot, wildones_plot, hjust="outward", heights=c(2,4),ncol=1, nrow=2) #5,7
```

***

```{=html}
<iframe style="border-radius:12px" src="https://open.spotify.com/embed/track/6tJPdGKrbAeyhkkhn44RHR?utm_source=generator&theme=0" width="100%" height="80" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>
```

```{=html}
<iframe style="border-radius:12px" src="https://open.spotify.com/embed/track/03FPFGGmCFCFX9X7vNB3JW?utm_source=generator&theme=0" width="100%" height="80" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>
```

**Chord comparison**

I have chosen Days of Thunder & Wild Ones from to corpus to do chordogram analysis with. Both songs contain vocals and have more 'normal' structure compared to most other synthwave tracks in the corpus.
Days of thunder seems to have less chord variation, while also being longer. Wild Ones has a lot of chord changes in the beginning, but the final stretch also seems to have no significant chord changes. It is surprising that both songs come out so different, because while the tracks do not sound the same, I do think that both artists make similar kinds of synthwave music.

### Introduction: Corpus Description {data-commentary-width=400}

**What is your corpus, why did you choose it, and what do you think is interesting about it?**

Synthwave (also called outrun, retrowave, or futuresynth) is an electronic music microgenre that is based predominantly on the music associated with action, science-fiction, and horror film soundtracks of the 1980s. Other influences are drawn from the decade's art and video games. Synthwave musicians often espouse nostalgia for 1980s culture and attempt to capture the era's atmosphere and celebrate it. (from wikipedia)

I chose this corpus because I am currently listening to a lot of synthwave music. I also listen to all my music on spotify, so I can use my playlists to build my corpus up quickly. I am also currently working on a synthwave rythm-game in unity, so exploring this corpus could also help with this side project.

**What is your corpus, why did you choose it, and what do you think is interesting about it?**

I intent to divide the corpus based on subgenres within synthwave. These subgenres are similar to the subgenres within heavy metal, but likely a lot more subtle. It would therefore be intresting to see if these subgenres are actually detectable within the corpus. I personally do not think there are very significant diferences between most of these subgenres, but we will see if the data agrees with that statement. As a second point of exploration, I want to distinguish between artists. This will probably fit nicely with subgenre detection, because you could imagine each artist's style to be similar to how subgenre styles are defined.

**How representative are the tracks in your corpus for the groups you want to compare?**

I will use a variety of artists and playlists to build the corpus. For subgenre detection I will use playlists with songs for each subgenre. For artist dectection I will include a few albums of synthwave artists that are intresting and feel different, to make the comparison intresting.

***

**Playlist**

```{=html}
<iframe style="border-radius:12px" src="https://open.spotify.com/embed/playlist/58spcwLelMvMpKvObWuwbN?utm_source=generator" width="100%" height="380" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>
```


```{r, echo = FALSE}
#kable(corpus)
#datatable(corpus)
```

### Corpus distribution {data-commentary-width=400}

```{r, echo = FALSE}
p1 <- ggplot(corpus, aes(track.popularity)) + geom_histogram(bins=50, fill = "#ff6c11") +
  labs(
  x="Popularity",
  y="Count",
  title="Popularity distribution of the corpus",
  caption="Source: Spotify API") +
  xlim(100,0) +
  theme_vapor()

p2 <- ggplot(corpus, aes(speechiness)) + geom_histogram(bins=50, fill = "#f9c80e") +
  labs(
  x="Speechness",
  y="Count",
  title="Speechness distribution of the corpus",
  caption="Source: Spotify API") +
  xlim(1,0) +
  theme_vapor()

#grid.arrange(p1, p2, ncol=2)
subplot(ggplotly(p1), ggplotly(p2)) %>% layout(title = '') %>% 
  # subplot titles: https://stackoverflow.com/questions/37285729/how-to-give-subtitles-for-subplot-in-plot-ly-using-r
  layout(annotations = list(list(x = 0.15 , y = 1.05, text = "Popularity distribution of the corpus", showarrow = F, xref='paper', yref='paper'),
  list(x = 0.85 , y = 1.05, text = "Speechness distribution of the corpus", showarrow = F, xref='paper', yref='paper'))
)
```

***

**The basics**

When working with a new dataset, it is often a great idea to create some basic plots to get a feeling for the dataset,
before diving into the actual research. The following two histograms will hopefully give a crude visualization of some
properties of the chosen corpus.

**Low popularity**

Lets start of by looking at the popularity of the songs in the matrix. Spotify API assigns a popularity value to each
track from 0 to 100. We can see that most songs have about 50 popularity. With some outliers close to minimum and maximum
popularity. The corpus has a surprising amount of popularity while not being a well known genre (or maybe it is?). It would
be nice if Spotify would explain how it determines popularity.

**Low Speechness**

It is clear from this histogram that speechness is very low in the corpus. This makes a lot of sense, because most tracks in the
corpus do not contain any vocals. What the plot does show us is that the expected speechness values and the Spotify provided values
do indeed match up, which is good.

### Energy & Valence {data-commentary-width=400}

```{r, echo = FALSE}
p <- ggplot(corpus, aes(valence, energy, color=mode, label = track.name)) + geom_point(alpha=.8, size=3) + scale_fill_discrete() +
  labs(
  x="Valence",
  y="Energy",
  title="Valence & Energy",
  caption="Source: Spotify API") +
  theme_vapor()

myplot = ggplotly(p)

# fixing weird legend formatting: https://stackoverflow.com/questions/49133395/strange-formatting-of-legend-in-ggplotly-in-r
for (i in 1:length(myplot$x$data)){
    if (!is.null(myplot$x$data[[i]]$name)){
        myplot$x$data[[i]]$name =  gsub("\\(","",str_split(myplot$x$data[[i]]$name,",")[[1]][1])
    }
}

myplot
```

```{r, include = FALSE} 
# font = "TTNorms"
corpus %>% 
  plot_ly(x = ~valence, y = ~energy, color = ~mode, size = 14, hoverinfo = "text",
  text = ~paste(" Song:", track.name, "<br>", "Artist(s):", artists.name, "<br>",
  "Valence:", valence, "<br>", "Energy:", energy)) %>%
  layout(font = list(color = "#eb34b1", size = 16, family = "TTNorms"))%>%
  layout(plot_bgcolor="#121212", paper_bgcolor="#181818") %>%
  layout(title="Valence & energy", xlabel = "hey") %>%
  layout(xaxis = list(title = "Valence", zerolinecolor = "#eb34b1", gridcolor = "#eb34b1"), yaxis = list(title = "Energy", zerolinecolor = "#eb34b1", gridcolor = "#eb34b1"))
```

***

**Vibe checking**

Energy and Valence can convey the mood of songs. Here red are minor songs.

### Dynamic Time Warping {data-commentary-width=400}

```{r, echo = FALSE}
## Crockett's Theme - Jan Hammer
crock_original <-
  get_tidy_audio_analysis("3TnJ7M6in8Pb5EyGBUK02Y") %>%
  select(segments) %>%
  unnest(segments) %>%
  select(start, duration, pitches)

## Crockett's Theme - Jan Hammer
crock_remaster <-
  get_tidy_audio_analysis("5srgpROEtK8KLKQl5FW7Ub") %>%
  select(segments) %>%
  unnest(segments) %>%
  select(start, duration, pitches)


p <- compmus_long_distance(
  crock_original %>% mutate(pitches = map(pitches, compmus_normalise, "chebyshev")),
  crock_remaster %>% mutate(pitches = map(pitches, compmus_normalise, "chebyshev")),
  feature = pitches,
  method = "euclidean"
) %>%
  ggplot(
    aes(
      x = xstart + xduration / 2,
      width = xduration,
      y = ystart + yduration / 2,
      height = yduration,
      fill = d
    )
  ) +
  geom_tile() +
  coord_equal() +
  labs(x = "Crockett's Theme - Jan Hammer", y = "Crockett's Theme (remaster) - Jan Hammer", title = "How do you remove those white bars?") +
  theme_vapor() +
  scale_fill_viridis_c(guide = NULL)

p
```

***

```{=html}
<iframe style="border-radius:12px" src="https://open.spotify.com/embed/track/3TnJ7M6in8Pb5EyGBUK02Y?utm_source=generator&theme=0" width="100%" height="80" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>
```

```{=html}
<iframe style="border-radius:12px" src="https://open.spotify.com/embed/track/5srgpROEtK8KLKQl5FW7Ub?utm_source=generator&theme=0" width="100%" height="80" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>
```

**Comparing original to remaster**

Jan Hammer's most iconic soundtrack has to be 'Crockett's Theme' from Miami Vice. Miami Vice is quite old now (originally aired in 1984),
but Jan Hammer's work on the soundtrack is great, and went on to inspire a lot of the modern Synthwave artists. Jan Hammer recently (2018) released a remaster
of 'Crockett's Theme' in the 'Special edition' album. I like this remaster better, but it is very subtly different from the original. 
Therefore it is probably the perfect candidate for this comparison.

**Analysis**

The plot shows that the original and the remastered soundtrack are indeed very similar.

### Self Similarity Matrix: Chroma and Timbre {data-commentary-width=400}

```{r, echo = FALSE}
turbokiller <-
  get_tidy_audio_analysis("10qbHF920zH5K8C8IcE5AL") %>%
  compmus_align(bars, segments) %>%
  select(bars) %>%
  unnest(bars) %>%
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "acentre", norm = "manhattan"
      )
  ) %>%
  mutate(
    timbre =
      map(segments,
        compmus_summarise, timbre,
        method = "mean"
      )
  )


p <- bind_rows(
  turbokiller %>% 
    compmus_self_similarity(pitches, "aitchison") %>% 
    mutate(d = d / max(d), type = "Chroma"),
  turbokiller %>% 
    compmus_self_similarity(timbre, "euclidean") %>% 
    mutate(d = d / max(d), type = "Timbre")
) %>% 
  ggplot(
    aes(
      x = xstart + xduration / 2,
      width = xduration,
      y = ystart + yduration / 2,
      height = yduration,
      fill = d
    )
  ) +
  geom_tile() +
  coord_fixed() +
  facet_wrap(~type) +
  scale_fill_viridis_c(option = "C") +
  theme_vapor() + theme(strip.text = element_text(colour = "#eb34b1"), panel.background  = element_rect(fill = "#121212", colour="#121212")) + 
  labs(x = "", y = "", title = "Turbo Killer - Carpenter Brut")

p
#plot_grid(p, p, hjust="outward", heights=c(2,4),ncol=1, nrow=2) #5,7
```

***

```{=html}
<iframe style="border-radius:12px" src="https://open.spotify.com/embed/track/10qbHF920zH5K8C8IcE5AL?utm_source=generator&theme=0" width="100%" height="80" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>
```

**Song Choice**

I wanted to explore the song 'Turbo Killer' by 'Carpenter Brut'. This song really stands out for quick pacing and constantly building and escalating upon the previous 'verse'. The song gives a sense of progression or fast movement/speed, and that is probably why this is one of my favorite tracks in this corpus.

**The Chroma matrix**

When looking at the Chroma matrix we see a lot of tiny changes in the first forty seconds. Every seven-ish seconds there is a change. After 40 seconds the song changes into high tempo guitar only, and the following blocks all add additional elements to this. The matrix turns out very interesting, because you can see how the song constantly builds up to more complexity.

**The Timbre matrix**

The Timbre matrix looks less interesting. There are no real verses, but you can tell where transitions to more complexity happen. What is very surprising is that the high point of the timbre matrix is at the end of the song.
